<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>index.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  <!-- https://realfavicongenerator.net/ -->
  
    <link
      
      rel="apple-touch-icon" 
      
      sizes="180x180" 
      
      href="apple-touch-icon.png" 
      
    >
  
    <link
      
      rel="icon" 
      
      type="image/png" 
      
      sizes="32x32" 
      
      href="favicon-32x32.png" 
      
    >
  
    <link
      
      rel="icon" 
      
      type="image/png" 
      
      sizes="16x16" 
      
      href="favicon-16x16.png" 
      
    >
  
    <link
      
      rel="manifest" 
      
      href="site.webmanifest" 
      
    >
  
    <link
      
      rel="mask-icon" 
      
      type="image/png" 
      
      sizes="16x16" 
      
      href="safari-pinned-tab.svg" 
      
      color="#ffab40" 
      
    >
  
    <link
      
      type="text/css" 
      
      rel="stylesheet" 
      
      href="pkg-styles/pkg-style.css" 
      
    >
  

  
    <meta
      
      name="msapplication-TileColor" 
      
      content="#ffab40" 
      
    >
  
    <meta
      
      name="theme-color" 
      
      content="#bdbdbd" 
      
    >
  
    <meta
      
      name="viewport" 
      
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" 
      
    >
  

  <link type="text/css" rel="stylesheet" href="jsdocp/styles/index.css"></head>
<body><div id="jsdocpNav" class="jsdocp-remove-me pkg-menu"
  data-jsdocp-sm-position="bottom"
  data-jsdocp-md-position="bottom"
  data-jsdocp-lg-position="top"
  data-jsdocp-sm-match-media="(max-width: 480px)"
  data-jsdocp-md-match-media="(min-width: 481px) and (max-width: 839px)"
  data-jsdocp-lg-match-media="(min-width: 840px)"
  data-jsdocp-sm-auto-hide="true"
  data-jsdocp-md-auto-hide="true"
  data-jsdocp-lg-auto-hide="false">
  <a href="index.html" id="jsdocpLogo"
    title="sqler"
    class="jsdocp-logo ">
    <b class="pkg-logo">
    
      <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg viewBox="0 0 29.26 29.26" y="0px" x="0px" version="1.1">
<g>
	<path
   d="M 3.2714844 12.164062 C 3.0504844 12.547062 2.921875 12.944422 2.921875 13.357422 L 2.921875 16.919922 C 2.921875 19.670922 8.1639531 21.902344 14.626953 21.902344 C 21.093953 21.902344 26.337891 19.670922 26.337891 16.919922 L 26.337891 13.357422 C 26.337891 12.944422 26.207375 12.547062 25.984375 12.164062 C 25.170706 13.571962 22.944745 14.736211 19.992188 15.388672 C 19.990472 16.830619 19.968304 18.235467 19.923828 18.3125 C 19.831308 18.472746 14.767068 21.396484 14.582031 21.396484 C 14.396995 21.396484 9.3327528 18.472746 9.2402344 18.3125 C 9.1955638 18.235128 9.175362 16.819813 9.1738281 15.371094 C 6.2660228 14.715075 4.0769893 13.558477 3.2714844 12.164062 z "
   />
	<path
   d="M14.627,23.31c-5.494,0-10.098-1.616-11.355-3.788c-0.221,0.381-0.35,0.779-0.35,1.191v3.564   c0,2.752,5.242,4.983,11.705,4.983c6.467,0,11.711-2.23,11.711-4.983v-3.564c0-0.412-0.131-0.81-0.354-1.19   C24.727,21.694,20.127,23.31,14.627,23.31z"
   />
	<path
   d="M 3.2402344 5.0429688 C 3.0392344 5.4089688 2.921875 5.7905937 2.921875 6.1835938 L 2.921875 9.7441406 C 2.921875 11.658469 5.4621005 13.319742 9.1816406 14.154297 C 9.1905174 13.111949 9.205954 12.203907 9.2402344 12.144531 C 9.3327524 11.984284 14.396995 9.0605469 14.582031 9.0605469 C 14.767068 9.0605469 19.83131 11.984284 19.923828 12.144531 C 19.958305 12.204246 19.975593 13.121262 19.984375 14.171875 C 23.754868 13.344294 26.337891 11.674559 26.337891 9.7441406 L 26.337891 6.1835938 C 26.337891 5.7905938 26.218578 5.4099687 26.017578 5.0429688 C 25.787578 7.0589688 20.785953 8.671875 14.626953 8.671875 C 8.4709531 8.671875 3.4692344 7.0579688 3.2402344 5.0429688 z "
   />
	<path
   d="M14.627,7.541c6.303,0,11.41-1.687,11.41-3.771c0-2.082-5.107-3.77-11.41-3.77   C8.328,0.001,3.219,1.689,3.219,3.771C3.219,5.854,8.328,7.541,14.627,7.541z"
   />
</g>
</svg>

    
    </b>
    <b id="jsdocpPkgName">sqler</b>
    <b>|</b>
    <hr/>
  </a>
  <a href="https://www.npmjs.com/package/sqler" id="jsdocpModule"
    title="npm"
    class="jsdocp-icon ">
    
    <svg version="1.1" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
      <g class="jsdocp-icon-svg-el pkg-icons" stroke="none" transform="translate(0,24) scale(0.1,-0.1)">
        <path d="M 0,120 0,0 l 120,0 120,0 0,120 0,120 -120,0 -120,0 z m 200,0 c 0,-73 0.23256,-80 0.23256,-80 0,0 -27.97435,0.741211 -40.61273,0.707427 C 159.61983,67.551504 160,70.949947 160,100 c 0,53 -2,60 -20,60 -18,0 -20,-7 -20,-60 l 0,-60 -40,0 -40,0 0,80 0,80 80,0 80,0 z"/>
      </g>
    </svg>
    
  </a>
  <a href="CHANGELOG.html" id="jsdocpChangelog" data-jsdocp-root-href="https://ugate.github.io/sqler/CHANGELOG.html"
    title="Changelog"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 64 64" height="64" width="64" xmlns="http://www.w3.org/2000/svg">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="M 29.896194,0.97873581 C 13.435048,0.97873581 1.1072664e-7,15.139296 0,32.489368 0,49.839439 13.435048,64 29.896194,64 46.357339,64 59.792385,49.839438 59.792388,32.489368 a 4.2273908,4.4556761 0 1 0 -8.453721,0 c -10e-7,12.534501 -9.550175,22.600399 -21.442473,22.600399 -11.892299,0 -21.4424739,-10.065899 -21.4424739,-22.600399 0,-12.5345 9.5501749,-22.6003988 21.4424739,-22.6003988 a 4.2273908,4.4556761 0 1 0 0,-8.91023339 z" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 55.529412,24.680907 -8.470588,10.142582 16.941176,0 z"/>
      <rect class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        transform="matrix(0.6882785,0.72544656,-0.6882785,0.72544656,0,0)" y="-38.592953" x="38.592953" height="39.814472" width="11.375563" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 23.705056,39.295314 8.338477,-1.11407 -7.281487,-7.674698 z"/>
    </svg>
    
  </a>
  <a href="https://ugate.github.io/sqler" id="jsdocpSourceCode"
    title="Source Code"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 10 16" width="24" height="24" xmlns="http://www.w3.org/2000/svg" id="jsdocpSourceIcon">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="evenodd"
        d="M8 1a1.993 1.993 0 0 0-1 3.72V6L5 8 3 6V4.72A1.993 1.993 0 0 0 2 1a1.993 1.993 0 0 0-1 3.72V6.5l3 3v1.78A1.993 1.993 0 0 0 5 15a1.993 1.993 0 0 0 1-3.72V9.5l3-3V4.72A1.993 1.993 0 0 0 8 1zM2 4.2C1.34 4.2.8 3.65.8 3c0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm3 10c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm3-10c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2z"></path>
    </svg>
    <!-- GitHub icon -->
    <svg version="1.1" viewBox="0 0 16 16" height="24" width="24" xmlns="http://www.w3.org/2000/svg" class="jsdocp-remove-me" id="jsdocpGithubIcon">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none"  fill-rule="evenodd"
        d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
    </svg>
    
  </a>
  <!-- versions.json should point to the latest list -->
  <a id="jsdocpVersionsIcon"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 64 64" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 63.999999,25.315556 -24.108295,0 9.74288,-10.026667 C 39.927261,5.6888885 24.210644,5.3333335 14.503322,14.933333 c -9.7073234,9.635555 -9.7073234,25.173334 0,34.808888 9.707322,9.635556 25.423939,9.635556 35.131262,0 4.835883,-4.764443 7.253823,-10.346666 7.253823,-17.386666 l 7.111592,0 c 0,7.039999 -3.1291,16.177777 -9.387301,22.364444 -12.480844,12.373334 -32.748879,12.373334 -45.2297224,0 -12.445286,-12.337778 -12.55196,-32.39111 -0.071116,-44.7288881 12.4808434,-12.3377774 32.4999734,-12.3377774 44.9808174,0 L 64,-5e-7 64,25.315556 Z" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 33.775734,17.777777 0,15.111111 12.445286,7.395556 -2.560173,4.302222 -15.218806,-9.031112 0,-17.777777 5.333693,0 z" />
    </svg>
    
  </a>
  <select id="jsdocpVersions"
    title="v0.8.1"
    data-jsdocp-version-base="/sqler"
    data-jsdocp-json-url="/sqler/versions.json"
    data-jsdocp-type=""
    data-jsdocp-from="1.0.0"
    data-jsdocp-version="0.8.1">
  </select>
</div>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Tutorials</li><li class="nav-item"><a href="tutorial-1-manual.html">Manual</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Dialect.html">Dialect</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Dialect.html#close">close</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Dialect.html#commit">commit</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Dialect.html#exec">exec</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Dialect.html#init">init</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Dialect.html#isAutocommit">isAutocommit</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Dialect.html#rollback">rollback</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Manager.html">Manager</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Manager.html#close">close</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Manager.html#commit">commit</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Manager.html#init">init</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Manager.html#pendingCommit">pendingCommit</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Manager.html#rollback">rollback</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li>
</nav>

<div id="main">
    
    <h1 class="page-title">index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const Dialect = require('./lib/dialect');

const Asynchro = require('asynchro');
const Fs = require('fs');
const { format } = require('util');
const Path = require('path');
const CRUD_TYPES = Object.freeze(['CREATE', 'READ', 'UPDATE', 'DELETE']);
const COMPARE = Object.freeze({
  '=': function eq(x, y) { return x === y; },
  '&lt;': function lt(x, y) { return x &lt; y; },
  '>': function gt(x, y) { return x > y; },
  '&lt;=': function lteq(x, y) { return x &lt;= y; },
  '>=': function gteq(x, y) { return x >= y; },
  '&lt;>': function noteq(x, y) { return x !== y; }
});

/**
 * The `cache` client responsible for regulating the frequency in which a SQL file is read by a {@link Manager}.
 * @typedef {Object} Cache
 * @property {Function} start An `async function()` that starts caching. This could be a `noop` or could start any background processing and/or capture of cached keys (depending on the type of
 * implementation).
 * @property {Function} stop An `async function()` that stops caching. This could be a `noop` or could stop any background processing and/or capture of cached keys (depending on the type of
 * implementation).
 * @property {Function} get An `async function(key)` that gets a corresponding SQL statement from cache using the specified _key_ to uniquily identify the SQL source (typically generated by a {@link Manager}).
 * The returned _object_ will contain the following values when present (otherwise, returns _null_):
 * - `item` - The cached SQL statement
 * - `stored` - The timestamp indicating the time when the SQL statement was stored in cache
 * - `ttl` - The timestamp indicating the remaining time left before the SQL statement will be removed from cache
 * @property {Function} set An `async function(key sql, ttlOverride)` that sets a SQL statement in cache, overriding the _time-to-live__ (in milliseconds) that may have been set by a {@link Manager}.
 * @property {Function} drop An `async function(key)` that removes the specified key from cache
 * @example
 * // cache options can be different depending on the needs of the implementing cache
 * const cacheOpts = {
 *  "expiresIn": 60000
 * };
 * // simple interval cache for illustration purposes
 * const bank = { store: {}, handles: {} };
 * const cache = {
 *  start: async () => {
 *    let cached, calTtl;
 *    for (let key in bank.handles) {
 *      clearInterval(bank.handles[key]);
 *      cached = bank.store.hasOwnProperty(key) ? bank.store[key] : null;
 *      calTtl = !cached|| isNaN(cached.ttl) ? cacheOpts.expiresIn : cached.ttl;
 *      bank.handles[key] = setInterval(() => delete bank.store[key], calTtl);
 *    }
 *  },
 *  stop: async () => {
 *    for (let key in bank.handles) {
 *      clearInterval(bank.handles[key]);
 *    }
 *  },
 *  get: async key => {
 *    const cached = bank.store.hasOwnProperty(key) ? bank.store[key] : null;
 *    if (cached) cached.ttl = Date.now() - cached.stored;
 *    return Promise.resolve(cached ? JSON.parse(JSON.stringify(cached)) : cached);
 *  },
 *  set: async (key, val, ttl) => {
 *    if (bank.handles[key]) clearInterval(bank.handles[key]);
 *    const calTtl = !ttl || isNaN(ttl) ? cacheOpts.expiresIn : ttl;
 *    bank.store[key] = { item: val, stored: Date.now(), ttl: calTtl };
 *    bank.handles[key] = setInterval(sql => delete bank.store[key], calTtl);
 *    return Promise.resolve();
 *  },
 *  drop: async () => {
 *    if (bank.handles[key]) {
 *      clearInterval(bank.handles[key]);
 *      delete bank.handles[key];
 *    }
 *    if (bank.store[key]) delete bank.store[key];
 *  }
 * };
 * 
 * // manager configuration
 * const conf = {
 *  // other required conf options here
 *  "db": {
 *    "connections": [
 *      {
 *        // other required connection conf options here
 *      }
 *    ]
 *  }
 * };
 * 
 * const mgr = new Manager(conf, cache);
 * await mgr.init();
 * // use the manager to execute SQL files that will
 * // be refreshed/re-read every 60 seconds
 */

/**
 * Private options for global {@link Manager} use
 * @typedef {Object} Manager~PrivateOptions
 * @property {String} username The username to connect to the database
 * @property {String} password The password to connect to the database
 * @property {String} [host] The host to connect to for the database
 * @property {String} [port] The port to connect to for the database (when not included in the host)
 * @property {String} [protocol] The protocol to use when connecting to the database
 * @property {String} [privatePath] The private path set by an originating {@link Manager} constructor (when not already set) that may be used by an implementing {@link Dialect} for private data use
 * (e.g. `TNS` files, etc.)
 */

/**
 * Configuration options for {@link Manager} use
 * @typedef {Object} Manager~ConfigurationOptions
 * @property {String} [mainPath] Root directory starting point to look for SQL files (defaults to `require.main` path or `process.cwd()`)
 * @property {String} [privatePath] Current working directory where generated files will be located (if any, defaults to `process.cwd()`)
 * @property {Object} db The _public_ facing database configuration
 * @property {Object} db.dialects An object that contains {@link Dialect} implementation details where each property name matches a dialect name and the value contains either the module class or a string
 * that points to a {@link Dialect} implementation for the given dialect (e.g. `{ dialects: { 'oracle': 'sqler-oracle' } }`). When using a directory path the dialect path will be prefixed with
 * `process.cwd()` before loading.
 * @property {Manager~ConnectionOptions[]} db.connections The connections options that will be used.
 * @property {Manager~UniversalOptions} univ The {@link Manager~UniversalOptions}
 */

/**
 * The universal configuration that, for security and sharing purposes, remains external to an application
 * @typedef {Object} Manager~UniversalOptions
 * @property {Object} db The database options that contain _private_ sensitive configuration. Each property should correspond to a {@link Manager~PrivateOptions} instance and the property name should
 * be linked to a {@link Manager~ConnectionOptions} `id` within `conf.db.connections`. Each {@link Manager~PrivateOptions} instance will be used to connect to the underlying database
 * (e.g. `{ db: myConnId: { host: "someDbhost.example.com", username: "someUser", password: "somePass" } }`)
 */

/**
* Options for connections used by {@link Manager}
 * @typedef {Object} Manager~ConnectionOptions
 * @property {String} id Identifies the connection within a {@link Manager~PrivateOptions}
 * @property {String} dialect The database dialect (e.g. mysql, mssql, oracle, etc.)
 * @property {String} name The name given to the database used as the property name on the {@link Manager} to access generated SQL functions (e.g. `name = 'example'` would result in a SQL function
 * connection container `manager.example`). The _name_ will also be used as the _cwd_ relative directory used when no dir is defined
 * @property {String} [dir=name] The alternative dir where `*.sql` files will be found relative to `mainPath` passed into a {@link Manager} constructor. The directory path will be used as the basis
 * for generating SQL statements from discovered SQL files. Each will be made accessible in the manager by name followed by an object for each name separated by period(s)
 * within the file name with the last entry as the executable {@link Manager~PreparedFunction}. For example, a connection named "conn1" and a SQL file named "user.team.details.sql" will be accessible within the manager
 * as "mgr.db.conn1.user.team.details()". But when `dir` is set to "myDir" the SQL files will be loaded from the "myDir" directory (relative to `mainPath`) instead of the default directory that matches the connection
 * name "conn1".
 * @property {Float} [version] A version that can be used for version substitutions within an SQL statement
 * @property {String} [service] The service name defined by the underlying database (may be required depending on the implementing {@link Dialect}
 * @property {Object} [binds] The global object that contains bind variable values that will be included in all SQL calls made under the connection for parameter `binds` if not overridden
 * by individual "binds" passed into the {@link Manager~PreparedFunction}
 * @property {Object} [substitutes] Key/value pairs that define global/static substitutions that will be made in prepared statements by replacing occurances of keys with corresponding values
 * @property {String} [host] The database host override for a value specified in {@link Manager~PrivateOptions}
 * @property {String} [port] The database port override for a value specified in {@link Manager~PrivateOptions}
 * @property {String} [protocol] The database protocol override for a value specified in {@link Manager~PrivateOptions}
 * @property {Object} [driverOptions] Options passed directly into the {@link Dialect} driver
 * @property {Object} [pool] The connection pool options (__overrides any `driverOptions` that may pertain the pool__)
 * @property {Integer} [pool.max] The maximum number of connections in the pool (__overrides any `driverOptions` that may pertain the pool max__)
 * @property {Integer} [pool.min] The minumum number of connections in the pool (__overrides any `driverOptions` that may pertain the pool min__)
 * @property {Integer} [pool.idle] The maximum time, in milliseconds, that a connection can be idle before being released (__overrides any `driverOptions` that may pertain the pool idle__)
 * @property {Integer} [pool.increment] The number of connections that are opened whenever a connection request exceeds the number of currently open connections
 * (__overrides any `driverOptions` that may pertain the pool increment__)
 * @property {Integer} [pool.timeout] The number of milliseconds that a connection request should wait in the queue before the request is terminated
 * (__overrides any `driverOptions` that may pertain the pool timeout__)
 * @property {String} [pool.alias] __When supported__, the alias of this pool in the connection pool cache (__overrides any `driverOptions` that may pertain the pool alias__)
 * @property {(Boolean | String[])} [log] When _logging_ is turned on for a given {@link Manager}, the specified tags will prefix the log output. Explicity set to `false` to disable
 * connection _log_ level logging even if it is turned on via the {@link Manager}.
 * @property {(Boolean | String[])} [logError] When _logging_ is turned on for a given {@link Manager}, the specified tags will prefix the error log output. Explicity set to `false` to disable
 * connection _error_ level logging even if it is turned on via the {@link Manager}.
 */

/**
 * Options that are passed to generated {@link Manager~PreparedFunction}
 * @typedef {Object} Manager~ExecOptions
 * @property {String} [type] The type of CRUD operation that is being executed (i.e. `CREATE`, `READ`, `UPDATE`, `DELETE`). __Mandatory only when the
 * generated/prepared SQL function was generated from a SQL file that was not prefixed with a valid CRUD type.__
 * @property {Object} [binds] The key/value pair of replacement parameters that will be bound in the SQL statement
 * @property {Integer} [numOfIterations] The number of times the SQL should be executed. When supported, should take less round-trips back to the DB
 * rather than calling generated SQL functions multiple times.
 * @property {Boolean} [returnErrors] A flag indicating that any errors that occur during execution should be returned rather then thrown
 * @property {Object} [driverOptions] Options that may override the {@link Manager~ConnectionOptions} for `driverOptions` that may be passed into the {@link Manager} constructor
 */
 // TODO : @property {String} [locale] The [BCP 47 language tag](https://tools.ietf.org/html/bcp47) locale that will be used for formatting dates contained in the `opts` bind variable values (when present)

/**
 * Generated/prepared SQL function
 * @async
 * @callback {Function} Manager~PreparedFunction
 * @param {Manager~ExecOptions} [opts] The SQL execution options
 * @param {String[]} [frags] Consists of any fragment segment names present in the SQL being executed that will be included in the final SQL statement. Any fragments present
 * in the SQL source will be excluded from the final SQL statement when there is no matching fragment name.
 * @returns {(Object[] | undefined | Error)} The result set of dynamically generated result models, undefined when executing a non-read SQL statement or an `Error` when
 * `opts.returnErrors` is _true_.
 */

 /**
  * Operational options for {@link Manager} methods
  * @typedef {Object} Manager~OperationOptions
  * @property {Object} [connections] An object that contains connection names as properties. Each optionally containing an object with `executeInSeries` that will override
  * any global options set directly on the {@link Manager~OperationOptions}. For example, `opts.connections.myConnection.executeInseries` would override `opts.executeInSeries`
  * for the connection named `myConnection`, but would use `opts.executeInSeries` for any other connections that ae not overridden.
  * @property {Boolean} [executeInSeries] Set to truthy to execute the operation in series, otherwise executes operation in parallel.
  */

/**
 * The database(s) manager entry point that autogenerates/manages SQL execution functions from underlying SQL statement files.
 * Vendor-specific implementations should implement {@link Dialect} and pass the class or module path into the constructor as `conf.db.dialects.myDialectClassOrModulePath`.
 * See [README.md](index.html) for more details about SQL related features.
 */
class Manager {

  /**
  * Creates a new database manager. Vendor-specific implementations should have constructors that accept properties defined by {@link Dialect}.
  * @param {Manager~ConfigurationOptions} conf The configuration options
  * @param {Cache} [cache] the {@link Cache} __like__ instance that will handle the logevity of the SQL statement before the SQL statement is re-read from the SQL file
  * @param {(Function | Boolean)} [logging] the `function(dbNames)` that will return a name/dialect specific `function(obj1OrMsg [, obj2OrSubst1, ..., obj2OrSubstN]))` that will handle database logging.
  * Pass `true` to use the console. Omit to disable logging altogether.
  */
  constructor(conf, cache, logging) {
    if (!conf) throw new Error('Database configuration is required');
    if (!conf.db.dialects) throw new Error('Database configuration.dialects are required');
    const mgr = internal(this), connCnt = conf.db.connections.length, mainPath = conf.mainPath || (require.main &amp;&amp; require.main.filename.replace(/([^\\\/]*)$/, '')) || process.cwd();
    const privatePath = conf.privatePath || process.cwd();
    const ns = 'db';
    mgr.this[ns] = {};
    mgr.at.sqls = new Array(connCnt);
    mgr.at.logError = logging === true ? generateLogger(console.error, ['db', 'error']) : (logging &amp;&amp; logging(['db', 'error'])) || console.error;
    mgr.at.log = logging === true ? generateLogger(console.log, ['db']) : (logging &amp;&amp; logging(['db'])) || console.log;
    //const reserved = Object.getOwnPropertyNames(Manager.prototype);
    for (let i = 0, conn, priv, dialect, dlct, track = {}; i &lt; connCnt; ++i) {
      conn = conf.db.connections[i];
      if (!conn.id) throw new Error(`Connection at index ${i} must have an "id"`);
      if (!conn.dialect || typeof conn.dialect !== 'string') throw new Error(`Connection at index ${i}/ID ${conn.id} must have have a valid "name"`);
      priv = conf.univ.db[conn.id]; // pull host/credentials from external conf resource
      if (!priv) throw new Error(`Connection at index ${i}/ID ${conn.id} has an "id" that cannot be found within the provided "conf.univ.db"`);
      priv = JSON.parse(JSON.stringify(priv));
      priv.privatePath = privatePath;
      conn.host = conn.host || priv.host;
      dlct = conn.dialect.toLowerCase();
      if (!conf.db.dialects.hasOwnProperty(dlct)) {
        throw new Error(`Database configuration.db.dialects does not contain an implementation definition/module for ${dlct} at connection index ${i}/ID ${conn.id} for host ${conn.host}`);
      }
      if (typeof conf.db.dialects[dlct] === 'string') {
        if (/^[a-z@]/i.test(conf.db.dialects[dlct])) conf.db.dialects[dlct] = require(conf.db.dialects[dlct]);
        else conf.db.dialects[dlct] = require(Path.join(process.cwd(), conf.db.dialects[dlct]));
      }
      //if (!(conf.db.dialects[dlct] instanceof Dialect)) throw new Error(`Database dialect for ${dlct} is not an instance of a sqler "${Dialect.constructor.name}" at connection index ${i}/ID ${conn.id} for host ${conn.host}`);
      if (conn.log !== false &amp;&amp; !conn.log) conn.log = [];
      if (conn.logError !== false &amp;&amp; !conn.logError) conn.logError = [];
      if (conn.log !== false) {
        let ltags = [...conn.log, 'db', conn.name, dlct, conn.service, conn.id, `v${conn.version || 0}`];
        conn.logging = logging === true ? generateLogger(console.log, ltags) : logging &amp;&amp; logging(ltags); // override dialect non-error logging
      }
      if (conn.logError !== false) {
        let ltags = [...conn.logError, 'db', conn.name, dlct, conn.service, conn.id, `v${conn.version || 0}`];
        conn.errorLogging = logging === true ? generateLogger(console.error, ltags) : logging &amp;&amp; logging(ltags); // override dialect error logging
      }
      dialect = new conf.db.dialects[dlct](priv, conn, track, conn.errorLogging, conn.logging, conf.debug || false);
      // prepared SQL functions from file(s) that reside under the defined name and dialect (or "default" when dialect is flagged accordingly)
      if (mgr.this[ns][conn.name]) throw new Error(`Database connection ID ${conn.id} cannot have a duplicate name for ${conn.name}`);
      //if (reserved.includes(conn.name)) throw new Error(`Database connection name ${conn.name} for ID ${conn.id} cannot be one of the following reserved names: ${reserved}`);
      mgr.at.sqls[i] = new SQLS(mainPath, cache, conn, (mgr.this[ns][conn.name] = {}), new DBS(dialect, conn));
    }
  }

  /**
   * Initializes the defined database connections
   * @returns {Object} An object that contains a property name that matches each connection that was processed (the property value is the number of operations processed per connection)
   */
  async init() {
    const mgr = internal(this);
    if (mgr.at.sqlsCount) throw new Error(`${mgr.at.sqlsCount} database(s) already initialized`);
    const rslt = await operation(mgr, 'init');
    mgr.at.sqlsCount = Object.getOwnPropertyNames(rslt).length;
    mgr.at.log(`${mgr.at.sqlsCount} database(s) are ready for use`);
    return mgr.at.sqlsCount;
  }

  /**
   * Commit the current transaction(s) in progress on either all the connections used by the manager or on the specified connection names.
   * @param {Manager~OperationOptions} [opts] The {@link Manager~OperationOptions} to use
   * @param {...String} [connNames] The connection names to perform the commit on (defaults to all connections)  
   * @returns {Object} An object that contains a property name that matches each connection that was processed (the property value is the number of operations processed per connection)
   */
  async commit(opts, ...connNames) {
    return operation(internal(this), 'commit', opts, connNames);
  }

  /**
   * Rollback the current transaction(s) in progress on either all the connections used by the manager or on the specified connection names.
   * @param {Manager~OperationOptions} [opts] The {@link Manager~OperationOptions} to use
   * @param {...String} [connNames] The connection names to perform the commit on (defaults to all connections)  
   * @returns {Object} An object that contains a property name that matches each connection that was processed (the property value is the number of operations processed per connection)
   */
  async rollback(opts, ...connNames) {
    return operation(internal(this), 'rollback', opts, connNames);
  }

   /**
   * Determines the number of pending transaction(s) in progress on either all the connections used by the manager or on the specified connection names.
   * @param {Manager~OperationOptions} [opts] The {@link Manager~OperationOptions} to use
   * @param {...String} [connNames] The connection names to perform the commit on (defaults to all connections)  
   * @returns {Object} An object that contains a property name that matches each connection that was processed (the property value is the number of operations processed per connection)
   */
  async pendingCommit(opts, ...connNames) {
    return operation(internal(this), 'pendingCommit', opts, connNames);
  }
 
  /**
   * Closes all database pools/connections/etc.
   * @returns {Object} An object that contains a property name that matches each connection that was processed (the property value is the number of operations processed per connection)
   */
  async close() {
    return operation(internal(this), 'close');
  }

  /**
   * @returns {String[]} The operation types
   */
  static get OPERATION_TYPES() {
    return CRUD_TYPES;
  }
}

/**
 * Executes one or more {@link SQLS} functions
 * @private
 * @param {Manager} mgr The _internal_/private {@link Manager} store
 * @param {String} funcName The async function name to call on each {@link SQLS} instance
 * @param {Manager~OperationOptions} [opts] The {@link Manager~OperationOptions} to use
 * @param {String[]} [connNames] The connection names to perform the commit on (defaults to all connections)
 * @returns {Object} The result from Asynchro
 */
async function operation(mgr, funcName, opts, connNames) {
  opts = opts || {};
  const cnl = (connNames &amp;&amp; connNames.length) || 0;
  const ax = new Asynchro({}, true);
  const queue = sqli => {
    const func = () => {
      if (typeof sqli[funcName] === 'function') return sqli[funcName]();
      return Promise.resolve(sqli[funcName]);
    };
    const hasOverride = opts.connections &amp;&amp; opts.connections[name] &amp;&amp; typeof opts.connections[name] === 'object' &amp;&amp; opts.connections[name].hasOwnProperty('executeInSeries');
    if (hasOverride ? opts.connections[name].executeInSeries : opts.executeInSeries) {
      ax.series(sqli.connectionName, func);
    } else {
      ax.parallel(sqli.connectionName, func);
    }
  }
  for (let i = 0, l = mgr.at.sqls.length; i &lt; l; ++i) {
    if (cnl) {
      if (!connNames.includes(mgr.at.sqls[i].connectionName)) continue;
      queue(mgr.at.sqls[i]);
    } else queue(mgr.at.sqls[i]);
  }
  return ax.run();
}

/**
 * Reads all the perpared SQL definition files for a specified name directory and adds a function to execute the SQL file contents
 * @private
 */
class SQLS {

  /**
   * Reads all the prepared SQL definition files for a specified name directory and adds a function to execute the SQL file contents
   * @constructs SQLS
   * @param {String} sqlBasePth the absolute path that SQL files will be included
   * @param {Cache} [cache] the {@link Cache} __like__ instance that will handle the logevity of the SQL statement before the SQL statement is re-read from the SQL file
   * @param {Manager~ConnectionOptions} conn options for the prepared statements
   * @param {Object} db the object where SQL retrieval methods will be stored (by file name parts separated by a period- except the file extension)
   * @param {DBS} dbs the database service to use
   */
  constructor(sqlBasePth, cache, conn, db, dbs) {
    if (!conn.name) throw new Error(`Connection ${conn.id} must have a name`);

    const sqls = internal(this);
    sqls.at.connectionName = conn.name;
    sqls.at.basePath = Path.join(sqlBasePth, conn.dir || conn.name);
    sqls.at.cache = cache;
    sqls.at.subrxs = sqls.at.subs &amp;&amp; [];
    sqls.at.db = db;
    sqls.at.dbs = dbs;
    sqls.at.conn = conn;
    sqls.at.subs = conn.substitutes;
    if (sqls.at.subs) for (let key in sqls.at.subs) sqls.at.subrxs.push({ from: new RegExp(key, 'g'), to: sqls.at.subs[key] }); // turn text value into global regexp
  }

  /**
   * Initializes the SQL paths
   */
  async init() {
    const sqls = internal(this);
    sqls.at.numOfPreparedStmts = 0;
    const prepare = async (cont, pnm, pdir) => {
      let pth, proms = [];
      try {
        cont = cont || sqls.at.db;
        pdir = pdir || sqls.at.basePath;
        const files = await Fs.promises.readdir(pdir);
        for (let fi = 0, stat, nm, ns, ext; fi &lt; files.length; ++fi) {
          pth = Path.resolve(pdir, files[fi]);
          stat = await Fs.promises.stat(pth);
          if (stat &amp;&amp; stat.isDirectory()) {
            nm = files[fi].replace(/[^0-9a-zA-Z]/g, '_');
            proms.push(prepare(cont[nm] = {}, `${pnm ? `${pnm}_` : ''}${nm}`, pth));
            continue;
          }
          nm = files[fi].replace(/[^0-9a-zA-Z\.]/g, '_');
          ns = nm.split('.');
          ext = ns.length > 1 ? ns.pop() : '';
          nm = `${sqls.at.conn.dialect}_${sqls.at.conn.name}_${pnm ? `${pnm}_` : ''}${ns.join('_')}`;
          for (let ni = 0, nl = ns.length, so = cont; ni &lt; nl; ++ni) {
            so[ns[ni]] = so[ns[ni]] || (ni &lt; nl - 1 ? {} : await sqls.this.prepared(nm, pth, ext));
            so = so[ns[ni]];
          }
        }
        await Promise.all(proms);
      } catch (err) {
        if (sqls.at.conn.erroLogging) sqls.at.conn.erroLogging(`Failed to build SQL statements from files in directory ${pth || pdir}`, err);
        throw err;
      }
    };
    await prepare();
    return sqls.at.dbs.init({ numOfPreparedStmts: sqls.at.numOfPreparedStmts });
  }

  /**
   * Generates a function that will execute a pre-defined SQL statement contained within a SQL file (and handle caching of that file)
   * @param {String} name the name of the SQL (excluding the extension)
   * @param {String} fpth the path to the SQL file to execute
   * @param {String} ext the file extension that will be used
   * @returns {Manager~PreparedFunction} an `async function` that executes SQL statement(s)
   */
  async prepared(name, fpth, ext) {
    const sqls = internal(this);
    if (sqls.at.conn.logging) sqls.at.conn.logging(`Generating prepared statement for ${fpth} at name ${name}`);
    let crud = Path.parse(fpth).name.match(/[^\.]*/)[0].toUpperCase();
    if (!CRUD_TYPES.includes(crud)) crud = null;
    if (sqls.at.conn.logging) {
      sqls.at.conn.logging(`Generating prepared statement for ${fpth} at name ${name}${
        crud ? '' : ` (statement execution must include "opts.type" set to one of ${CRUD_TYPES.join(',')} since the SQL file path is not prefixed with the type)`}`);
    }
    // cache the SQL statement capture in order to accommodate dynamic file updates on expiration
    sqls.at.stms = sqls.at.stms || { methods: {} };
    sqls.at.stms.methods[name] = {};
    if (sqls.at.cache) {
      const id = `sqler:db:${name}${ext ? `:${ext}` : ''}`;
      sqls.at.stms.methods[name][ext] = async function cachedSql(opts, execFn) { // execute the SQL statement with cached statements
        let sql;
        const cached = await sqls.at.cache.get(id);
        if (!cached || !cached.item) {
          if (sqls.at.conn.logging) sqls.at.conn.logging(`Refreshing cached ${fpth} at ID ${id}`);
          sql = await readSqlFile();
          sqls.at.cache.set(id, sql); // no need to await set
        } else sql = cached.item;
        return await execFn(sql);
      };
    } else {
      if (sqls.at.conn.logging) sqls.at.conn.logging(`Setting static ${fpth} at "${name}"`);
      const sql = await readSqlFile();
      sqls.at.stms.methods[name][ext] = async function staticSql(opts, execFn) { // execute the SQL statement with static statements
        return await execFn(sql);
      };
    }
    sqls.at.numOfPreparedStmts++;

    /**
     * @returns {String} the SQL contents from the SQL file
     */
    async function readSqlFile() {
      var data = await Fs.promises.readFile(fpth, { encoding: 'utf8' });
      if (data &amp;&amp; sqls.at.subrxs) for (let i = 0, l = sqls.at.subrxs.length; i &lt; l; ++i) data = data.replace(sqls.at.subrxs[i].from, sqls.at.subrxs[i].to); // substitutions
      const dt = ext === 'json' ? JSON.parse(data.toString('utf8').replace(/^\uFEFF/, '')) : data; // when present, replace BOM before parsing JSON result
      return dt || data;
    }

    /**
    * Sets/formats SQL parameters and executes an SQL statement
    * @see Manager~PreparedFunction
    */
    return async function execSqlPublic(opts, frags) {
      const binds = {}, mopt = { binds, opts: frags }, type = (opts &amp;&amp; opts.type &amp;&amp; opts.type.toUpperCase()) || crud;
      if (!type || !CRUD_TYPES.includes(type)) {
        throw new Error(`Statement execution must include "opts.type" set to one of ${CRUD_TYPES.join(',')} since the SQL file path was not prefixed with a type (found: ${type})`);
      }
      if (sqls.at.conn.binds) for (let i in sqls.at.conn.binds) {
        if (!opts || !opts.binds || !opts.binds.hasOwnProperty(i)) {
          binds[i] = sqls.at.conn.binds[i]; // add per connection static parameters when not overridden
        }
      }
      if (opts &amp;&amp; opts.binds) {
        for (let i in opts.binds) {
          binds[i] = (opts.binds[i] instanceof Date &amp;&amp; opts.binds[i].toISOString()) || opts.binds[i]; // convert dates to ANSI format for use in SQL
        }
      }
      const driverOptions = opts &amp;&amp; opts.driverOptions ? opts.driverOptions : undefined;
      return await sqls.at.stms.methods[name][ext](mopt, sqls.this.genExecSqlFromFileFunction(fpth, type, binds, frags, driverOptions));
    };
  }

  genExecSqlFromFileFunction(fpth, type, binds, frags, driverOptions) {
    const sqls = internal(this), opts = { type, binds, driverOptions };
    return async function execSqlFromFile(sql) {
      return await sqls.at.dbs.exec(fpth, sql, opts, frags);
    };
  }

  /**
   * Iterates through and commits the different database connection transactions
   */
  async commit() {
    return internal(this).at.dbs.commit();
  }

  /**
   * Iterates through and rollback the different database connection transactions
   */
  async rollback() {
    return internal(this).at.dbs.rollback();
  }

  /**
   * Iterates through and terminates the different database connection pools
   */
  async close() {
    return internal(this).at.dbs.close();
  }

  /**
   * @returns {Integer} The number of executed transactions that are pending commit
   */
  get pendingCommit() {
    return internal(this).at.dbs.pendingCommit;
  }

  /**
   * @returns {Integer} the number of prepared statements found in SQL files
   */
  get numOfPreparedStmts() {
    return internal(this).at.numOfPreparedStmts || 0;
  }

  /**
   * @returns {String} the connection name associated with the {@link SQLS} instance
   */
  get connectionName() {
    return internal(this).at.connectionName;
  }
}

/**
 * Database service
 * @private
 */
class DBS {

  /**
   * Database service constructor
   * @constructs DBS
   * @param {Dialect} dialect the database dialect implementation/executor to use
   * @param {Manager~ConnectionOptions} conn the connection options
   */
  constructor(dialect, conn) {
    const dbs = internal(this);
    dbs.at.dialect = dialect;
    dbs.at.dialectName = conn.dialect &amp;&amp; conn.dialect.toLowerCase();
    dbs.at.errorLogging = conn &amp;&amp; conn.errorLogging;
    dbs.at.logging = conn &amp;&amp; conn.logging;
    dbs.at.version = conn.version || 0;
    dbs.at.pending = 0;
  }

  /**
   * Initializes the database service
   * @param {Object} [opts] initializing options passed into the underlying database implementation/executor
   * @returns {Object} the connection pool
   */
  async init(opts) {
    const dbs = internal(this);
    return await dbs.at.dialect.init(opts);
  }

  /**
  * Executes SQL using the underlying framework API
  * @param {String} fpth The originating file path where the SQL resides
  * @param {String} sql The SQL to execute with optional substitutions {@link DBS#frag}
  * @param {Manager~ExecOptions} opts The eectution options
  * @param {String[]} frags The frament keys within the SQL that will be retained
  * @returns {(Object[] | undefined | Error)} The execution results, `undefined` when not perfroming a read or an error when `opts.returnErrors` is true
  */
  async exec(fpth, sql, opts, frags) {
    const dbs = internal(this);
    const sqlf = dbs.this.frag(sql, frags, opts.binds);
    // framework that executes SQL may output SQL, so, we dont want to output it again if logging is on
    if (dbs.at.logging) {
      dbs.at.logging(`Executing SQL ${fpth} with options ${JSON.stringify(opts)}${frags ? ` framents used ${JSON.stringify(frags)}` : ''}`);
    }
    let rslt;
    try {
      rslt = await dbs.at.dialect.exec(sqlf, generateDbsOpts(dbs, 'exec', opts), frags); // execute the prepared SQL statement
    } catch (err) {
      if (dbs.at.errorLogging) {
        dbs.at.errorLogging(`SQL ${fpth} failed ${err.message || JSON.stringify(err)} (options: ${JSON.stringify(opts)}, connections: ${dbs.at.dialect.lastConnectionCount || 'N/A'}, in use: ${dbs.at.dialect.lastConnectionInUseCount || 'N/A'})`);
      }
      if (opts.returnErrors) return err;
      else throw err;
    }
    if (dbs.at.logging) {
      dbs.at.logging(`SQL ${fpth} returned with ${(rslt &amp;&amp; rslt.length) || 0} records (options: ${JSON.stringify(opts)}, connections: ${dbs.at.dialect.lastConnectionCount || 'N/A'}, in use: ${dbs.at.dialect.lastConnectionInUseCount || 'N/A'})`);
    }
    return rslt;
  }

  /**
  * Removes any SQL fragments that are wrapped around [[? someKey]] and [[?]] when the specified keys does not contain the discovered key (same for dialect and version keys)
  * Replaces any SQL parameters that are wrapped around :someParam with the indexed parameter names (i.e. :someParam :someParam1 ...) and adds the replacement value to the supplied `binds`
  * @param {String} sql the SQL to defragement
  * @param {String[]} [keys] fragment keys which will remain intact within the SQL
  * @param {Object} [rplmts] an object that contains the SQL parameterized `binds` that will be used for parameterized array composition
  * @returns {String} the defragmented SQL
  */
  frag(sql, keys, rplmts) {
    if (!sql) return sql;
    const dbs = internal(this);
    sql = sql.replace(/(:)([a-z]+[0-9]*?)/gi, function sqlArrayRpl(match, pkey, key) {
      for (var i = 0, vals = key &amp;&amp; rplmts &amp;&amp; Array.isArray(rplmts[key]) &amp;&amp; rplmts[key], keys = '', l = vals &amp;&amp; vals.length; i &lt; l; ++i) {
        keys += ((keys &amp;&amp; ', ') || '') + pkey + key + (i || '');
        rplmts[key + (i || '')] = vals[i];
      }
      return keys || (pkey + key);
    });
    sql = sql.replace(/((?:\r?\n|\n)*)-{0,2}\[\[\!(?!\[\[\!)\s*(\w+)\s*\]\](?:\r?\n|\n)*([\S\s]*?)-{0,2}\[\[\!\]\]((?:\r?\n|\n)*)/g, function sqlDiaRpl(match, lb1, key, fsql, lb2) {
      return (key &amp;&amp; key.toLowerCase() === dbs.at.dialectName &amp;&amp; fsql &amp;&amp; (lb1 + fsql)) || ((lb1 || lb2) &amp;&amp; ' ') || '';
    });
    sql = sql.replace(/((?:\r?\n|\n)*)-{0,2}\[\[version(?!\[\[version)\s*(=|&lt;=?|>=?|&lt;>)\s*[+-]?(\d+\.?\d*)\s*\]\](?:\r?\n|\n)*([\S\s]*?)-{0,2}\[\[version\]\]((?:\r?\n|\n)*)/gi, function sqlVerRpl(match, lb1, key, ver, fsql, lb2) {
      return (key &amp;&amp; ver &amp;&amp; !isNaN(ver = parseFloat(ver)) &amp;&amp; COMPARE[key](dbs.at.version, ver) &amp;&amp; fsql &amp;&amp; (lb1 + fsql)) || ((lb1 || lb2) &amp;&amp; ' ') || '';
    });
    return sql.replace(/((?:\r?\n|\n)*)-{0,2}\[\[\?(?!\[\[\?)\s*(\w+)\s*\]\](?:\r?\n|\n)*([\S\s]*?)-{0,2}\[\[\?\]\]((?:\r?\n|\n)*)/g, function sqlFragRpl(match, lb1, key, fsql, lb2) {
      return (key &amp;&amp; keys &amp;&amp; keys.indexOf(key) >= 0 &amp;&amp; fsql &amp;&amp; (lb1 + fsql)) || ((lb1 || lb2) &amp;&amp; ' ') || '';
    });
  }

  /**
   * Iterates through and commits the different database connection transactions
   */
  async commit() {
    const dbs = internal(this);
    const rslt = await dbs.at.dialect.commit(generateDbsOpts(dbs, 'commit'));
    dbs.at.pending = 0;
    return rslt;
  }

  /**
   * Iterates through and rollback the different database connection transactions
   */
  async rollback() {
    const dbs = internal(this);
    const rslt = dbs.at.dialect.rollback(generateDbsOpts(dbs, 'rollback'));
    dbs.at.pending = 0;
    return rslt;
  }

  /**
   * Iterates through and terminates the different database connection pools
   */
  async close() {
    const dbs = internal(this);
    const rslt = await dbs.at.dialect.close(generateDbsOpts(dbs, 'close'));
    dbs.at.pending = 0;
    return rslt;
  }

  /**
   * @returns {Integer} The number of executed transactions that are pending commit
   */
  get pendingCommit() {
    const dbs = internal(this);
    return dbs.at.pending;
  }
}

/**
 * Generates options for {@link DBS}
 * @private
 * @param {DBS} dbs The {@link DBS} state instance
 * @param {String} operation The operaion for whcih the generated options are generated for (e.g. exec, commit, rollback, close, etc.)
 * @param {DialectOptions} [opts] Optional options where additional options will be set
 * @returns {DialectOptions} The {@link Dialect} options
 */
function generateDbsOpts(dbs, operation, opts) {
  const ropts = opts || {};
  if (operation === 'exec') {
    dbs.at.pending += opts.type === 'READ' || dbs.at.dialect.isAutocommit(opts) ? 0 : 1;
  }
  ropts.tx = { pending: dbs.at.pending };
  return ropts;
}

/**
 * Generate a {@link Manager} _logger_
 * @private
 * @param {Function} log The `function(...args)` that will log out the arguments
 * @param {Sring[]} [tags] The tags that will prefix the log output
 */
function generateLogger(log, tags) {
  return function dbManagerLogger(o) {
    const logs = typeof o === 'string' ? [format.apply(null, arguments)] : arguments;
    for (let i = 0, l = logs.length; i &lt; l; ++i) {
      log(`[${tags ? tags.join() : ''}] ${logs[i]}`);
    }
  };
}

module.exports = Object.freeze({ Manager, Dialect });

// private mapping
let map = new WeakMap();
let internal = function (object) {
  if (!map.has(object)) {
    map.set(object, {});
  }
  return {
    at: map.get(object),
    this: object
  };
};</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<div id="jsdocpChangelogContent" data-title="CHANGELOG v0.8.1">
  <svg class="jsdocp-close" id="jsdocpChangelogClose" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
  </svg>
  <h2><a href="https://ugate.github.io/sqler/tree/v0.8.1">0.8.1</a> (2020-01-03)</h2>
<p><a href="https://ugate.github.io/sqler/compare/v0.8.0...v0.8.1">Full Changelog</a></p>
<p><strong>Fixes:</strong></p>
<ul>
<li><a href="https://ugate.github.io/sqler/commit/4f9f9bc9e3a1addd797b2a197ec1dc839e972d14">[FIX]: Connection ID validation</a></li>
</ul>
</div>



<script src="jsdocp/scripts/index.js"></script></body>
</html>
